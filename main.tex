% ! TeX root = main.tex
\documentclass[aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{multicol}
\usepackage{pgfpages}
\usepackage[draft]{pdfcomment}
\title{Research directions for Aggregate Computing with
Machine Learning}
\author[G.Aguzzi]{
  \textbf{Gianluca Aguzzi}\inst{1}
}
\institute{
  \inst{1}
  \texttt{Alma Mater Studiorum} -- Universit√† di Bologna, Cesena, Italy
}
\usetheme{material}
%& Theme
\usetheme{material}
\useLightTheme
\usePrimaryBlueGrey
\useAccentIndigo
%% Document starts
\begin{document}
\setbeamercovered{transparent=10}
\begin{frame}
  \titlepage
  \pdfcomment{
    Here I think I do not say so much, just a little bit of an introduction about who I am
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Collective (Self) Adaptive System}
\begin{frame}{Background}
  \begin{card}[Collective (Self-)Adaptive Systems]
  \pdfcomment{
    These kinds of systems are the target of our approach. They consist of a large number of communicating entities that exhibit a kind of intelligent behaviour that arises through learning.
    Learning is an important mechanism to enforce adaptability to errors, environmental changes, openness and heterogeneity.
    For years, there have been various approaches in the literature to deal with this complexity. In my research group, we focus on Aggregate Computing.
  }
  \end{card}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{State of the art solution}
\begin{frame}{Aggregate Computing}
  \begin{card}
    \begin{itemize}
      \item <1-> a top-down global-to-local approach to express collective behaviour
      \item <2-> rooted on \textit{field-calculus}
      \item <3-> used in various scenarios ranging from smart cities to crowd engineering
    \end{itemize}
  \end{card}
  \pause[3]
  \begin{cardRed}[Problem]
    \centering
    \textit{Building block design is hard}
  \end{cardRed}

  \pdfcomment{
    It is a top-down approach that makes it possible to coordinate large-scale, possibly heterogeneous, highly dynamic systems. It mainly consists of manipulating a distributed data structure called Computational Field. In contrast to swarm intelligent approaches, the idea here is to "program" the self-organisation by representing it as something like a first-class citizen of the language. The program then can be split in each node, so that the collective behaviour can be easily scaled in very large systems (hundreds or thousands of nodes).
    A key advantage of this approach is its compositionality, which is inspired by functional programming.
     The paradigm is based on a small algebra called the field calculus, which expresses the minimal constructs that can be used to express any kind of spatiotemporal computation. On top of this, we built intermediate-level abstractions, called Building-Block, which consist of the common patterns used in Aggregate Computing.
    We then used them to build domain-oriented applications to help developers express complex collective behaviour.
    Over the last ten/fifteen years, this methodology has grown rapidly. It is being used in many contexts such as crowd engineering, swarm robotics, and smart cities.
    Pragmatically, we see that it is not easy to develop building blocks that work well in different scenarios (e.g., high node mobility).
    Sometimes it is a very tricky process of fine-tuning where we need to apply some constants to make our application work.
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Machine Learning}
\begin{frame}{Machine Learning}
  \begin{card}{
    \begin{itemize}
      \item <1->Supervised Learning applied in %cite a,b,c
      \item <2->Reinforcement Learning applied in %cite a,b,c
      \item <3->Evolutionary Computing applied in %cite a,b,c
    \end{itemize}
  }
  \end{card}
  \pause[3]
  \begin{cardRed}[Problem]
    \centering
    \textit{Solutions are application-specific}
  \end{cardRed}
  \pdfcomment {
    Another way of dealing with these systems is to teach them to behave properly. 
    Here, thanks in part to the new waves of interest in Machine Learning, 
    there are many insights, solutions, and ideas. 
    Reinforcement Learning, Supervised Learning, Evolutionary Computing are all tactics used in this direction. 
    Although these solutions lead to good results, they are generally very context-specific and cannot be easily applied in different situations. 
    Here we have to deal with non-stationary environments, large research space and a distributed control, which makes Machine Learning generalisation in different contexts very difficult.
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem statement}
\begin{frame}{Problem statement}
  \begin{card}
    {
      \color{accent}
      Extend Aggregate Computing paradigm to include the Machine Learning capability to improve adaptability and simplify the definition and refinement of collective behaviour.
    }
  \end{card}
  \pdfcomment{
    Thus, our overall goal is:
    Extend common aggregate computing paradigm to include the Machine Learning capability to improve adaptability and simplify the definition and refinement of collective behaviour.
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Motivation}
\begin{frame}{Motivation}
  \begin{card}
    \begin{itemize}
      \item <1-> Aggregate Computing is scale independent by construction
      \item <2-> Hybrid collective program description
      \item <3-> Try to improve current state-of-the-art Machine Learning applying in CSAS
    \end{itemize}
  \end{card}
  \pdfcomment{
    Indeed, aggregate computing currently has a key component that makes it eminently suitable for application in CSAS, namely its scale-independent nature. A program is expressed for a logical system and can then be transparently applied to any size 
    (or to any topology, thanks to the recent work of the pulverised architecture).
    Moreover, we would like to explore a new way to declare collective behaviour: A part of the collective behaviour is still expressed in terms of API composition and function calls, while another part, where humans have difficulty expressing the correct behaviour, is distilled through learning.
    Finally, we want to deepen the approach of Machine Learning in this very complex kind of system. Although some work has been started in the last years, Field-Based coordination has never meet Machine Learning. It could open new opportunities and techniques that can also improve the current results of state-of-the-art machine learning algorithms.   
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Research Question}
\begin{frame}{Research Questions}
  \begin{card}
    \begin{itemize}
      \item <1-> What kind of Machine Learning approach is useful in combination with Aggregate Computing?
      \item <2-> At what level of abstraction can Machine Learning be useful for Aggregate Computing
      \item <3-> What does Aggregate Computing have in common with Machine Learning, applied to Collective Adaptive System?
    \end{itemize}  
  \end{card}
  \pdfcomment 
  {
    The research directions we want to tackle are: 
    i) what kind of machine learning is useful in combination with Aggregate Computing? 
    ii) at what level of abstraction can Machine Learning be useful for Aggregate Computing? 
    iii) what does Aggregate Computing have in common with ML, applied to Collective Adaptive System?
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Early results}
\begin{frame}{Early results}
  \pdfcomment {
    So, speaking about the early work and results, we mainly try these directions:
    i) Combine Aggregate Computing with Supervised Learning 
    ii) Combine Aggregate Computing with Evolutionary Computing iii) 
    And finally, iii) we combine Aggregate Computing with Reinforcement Learning.
}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Enforcements}
\begin{frame}{Enforcements}
  \pdfcomment{
    Currently, we formulate our learning problem as Homogenous Team Learning, 
    which in a sense is very close to the Aggregate Computing setting. 
    Indeed, each agent should perform the same behaviour to obtain a global result.
    We then run this test offline using Alchemist, 
    a well-known and robust simulator used with Aggregate Computing. 
    Then we focus on improving the building blocks because this is something very important in our research area. 
    If we can increase the block definition or improvement, it will improve our current solutions.  
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Computational Model}
\begin{frame}{Interaction model}
  \pdfcomment{
    Before I talk about my early works, let me briefly explain what aggregate computing is. 
    Here, we view a system as a large group of computing nodes connected by a neighbour relationship, 
    which can be either physical (i.e., one node has a connection to another node) or logical/position-based.
    Each node has only a partial view of the entire aggregate. Interaction with the neighbourhood 
    is done through message passing. 
    The information exchanged depends on the execution model of this system..
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Execution model}
  \pdfcomment{
    An aggregate programme has two points of view: i) A collective viewpoint, which refers to the evaluation of the computational field, and a local viewpoint, which follows the global behaviour and periodically executes a round, i.e., the atomic part of the computation in an aggregate system.
    A round consists of:  i) a context creation where nodes take in values from sensors, messages from the neighbourhood, and their old output. ii) Then, the aggregate program is evaluated and export is created.
    an export is a data structure that contains all the information that the neighbours need to evaluate the program). iii) With this export, a node can perform a local actuation and iiii) finally, each node shares the export in broadcast to the entire neighbourhood.
    Note that any computation is asynchronous to other nodes.
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Gradient/Hop count example}
  \pdfcomment{
    Currently, our reference building block is the gradient from a source zone.
    It generates a computational field in which each node generates the distance from a node marked as a source. 
    The hop count problem is very similar, but instead of distance, the program returns the number of hops from 
    a destination node. A naive implementation of this algorithm consists in taking the minimum value from 
    the neighbour field and incremented by the distance to it.
    Create an image that graphically represents the importance of the gradient and the number of hops
  }
%% Here put an image that show the step to compute this field.
\end{frame}
\begin{frame}{Gradient/Hop count example: Problem}
  \pdfcomment{
    This very simple solution suffers from the slow-rising problem: 
    suppose you have two sources and one of them eventually disappears. 
    In this case, the nodes take more time to reach the correct value, 
    as opposed to the time taken at the beginning of the algorithm's execution.
    So our first attempt is to reduce the convergence time of the basic hop-count algorithm. 
    This is already done algorithmically, but we need something that learns how to achieve faster 
    convergence on its own.  
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Aggregate Computing and Supervised Learning}
  \pdfcomment{
    So starting from the initial global setting A, we would achieve a stable position B. 
    In the gradient problem, for example, the stable position consists of the distance to a node.
    In a way, it is inspired by Graph Neural Network, where the input of the network is a graph and 
    the ground truth could be a graph in turn.
    There are some experiments in this direction here. We note that it is very difficult to achieve
    a performance boost in this way. Indeed we do not know the correct outcome for each time step, 
    which makes it difficult to lead the collective to improve performance.
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Aggregate Computing and Evolutionary computing}
  \pdfcomment{
    Here we do not need a correct ground truth, but we only need to specify a fitness 
    function that evaluates the overall behaviour of the system. 
    This type of method is used in swarm robotics and even in automatic design. 
    Here we observe very low performance in converging to a good solution. 
    Sometimes a solution is never reached and the search is trapped in a local minimum
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{References}
\begin{frame}{Aggregate Computing and Reinforcement Learning}
  \pdfcomment{
    This combination seems to be one of the most suitable for several reasons:
    i) in the literature, it seems the best way to integrate learning into CSAS 
    ii) it is designed to maximise the long term outcome, not just the best local response.
    iii) even if the aggregate program seems to be a distributed regression, it is quite easy to encode problems in terms of agent states and actions.  
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Aggregate Computing and Reinforcement Learning: Hop count}
  \pdfcomment{
    Our first attempt is quite simple: we try to use standard Q-learning to speed up hop count convergence. There seems to reach good performance in the literature, although there are no theorems proving convergence as in the single-agent context.
    For example, one action that an agent might take is to increase output
    Instead, the state is in some way built upon the current node and neighbourhood outputs. 
    In this case, we use a window of difference from the neighbours that encodes the rate of increase in hop count.
    The reward signal is: 0) if the output is correct at a given time t -1) otherwise.
    With this very simple setting, we can outperform the standard hop count algorithm.
    This is a very early result. More studies are needed to understand if this solution can be generalised.
  }
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Conclusion}
  \pdfcomment{
    In summary, this first year of my research has allowed me to observe current trends in CSAS. 
    Our goal is to endow Aggregate Computing with intelligence, which in itself is a good framework for
    this kind of system
    The first experimental tests have shown that Reinforcement Learning seems to be a good method that can be applied in our scenario, even if we need a deeper analysis to verify its effectiveness in other applications
  } 
\end{frame}

\begin{frame}{References}

\end{frame}
\end{document}
